[{"title":"Midori","type":0,"sectionRef":"#","url":"/midori/docs/intro","content":"Midori Midori is testing library for Roblox.","keywords":""},{"title":"Midori","type":0,"sectionRef":"#","url":"/midori/api/Midori","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Midori","url":"/midori/api/Midori#functions","content":" "},{"title":"runTests​","type":1,"pageTitle":"Midori","url":"/midori/api/Midori#runTests","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Midori.runTests( root: Instance , config: Config? ) → () "},{"title":"Types","type":1,"pageTitle":"Midori","url":"/midori/api/Midori##","content":""},{"title":"​","type":1,"pageTitle":"Midori","url":"/midori/api/Midori#Config","content":"interface Config { showTimeoutWarning: boolean?-- If true, a warning will show if a test runs longer than timeoutWarningDelay timeoutWarningDelay: number?-- Time in seconds for a test to show a timeout warning concurrent: boolean?-- If true, all tests will run concurrently }  Runs the tests found in all the .test modules inside of the root instance. Example: Midori.runTests(YourLibrary, { timeoutWarningDelay = 10, }) Default config values: { showTimeoutWarning = true, timeoutWarningDelay = 15, concurrent = false, } caution The concurrent option should only be used if your tests do not affect each other at all. If used, tests should not access variables other tests access. The code that is being tested should also not contain any global state. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/midori/docs/GettingStarted","content":"","keywords":""},{"title":"Creating Tests​","type":1,"pageTitle":"Getting Started","url":"/midori/docs/GettingStarted#creating-tests","content":"First, to create a test module, create a new ModuleScript with a .test suffix. Test modules are required to return function and a table called x will be passed in. x contains utility asserts like shouldThrow, functions to register tests, and more. A simple test module might look like this: Module.test.lua return function(x) x.test(&quot;1 == 1&quot;, function() assert(1 == 1) end) end  "},{"title":"Running Tests​","type":1,"pageTitle":"Getting Started","url":"/midori/docs/GettingStarted#running-tests","content":"To run your tests, call Midori.runTests with an instance. Midori will find all .test modules inside that instance. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Midori = require(ReplicatedStorge.Packages.Midori) Midori.runTests(ReplicatedStorage.YourLibrary)  "},{"title":"Debugging Tests​","type":1,"pageTitle":"Getting Started","url":"/midori/docs/GettingStarted#debugging-tests","content":"To isolate certain tests, x provides a testFOCUS and a testSKIP function. return function(x) -- Only tests that have been called with `testFOCUS` will run. x.testFOCUS(&quot;focus&quot; function() end) end  return function(x) -- This test will not run. x.testSKIP(&quot;skip&quot; function() end) end  "},{"title":"x","type":0,"sectionRef":"#","url":"/midori/api/x","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"x","url":"/midori/api/x#functions","content":" "},{"title":"test​","type":1,"pageTitle":"x","url":"/midori/api/x#test","content":"&lt;/&gt; x.test( name: string, callback: (context: {}) → () ) → () Creates a new test inside of the current scope. test(&quot;1 == 1&quot;, function() assert(1 == 1) end)   "},{"title":"testFOCUS​","type":1,"pageTitle":"x","url":"/midori/api/x#testFOCUS","content":"&lt;/&gt; x.testFOCUS( name: string, callback: (context: {}) → () ) → () Creates a new test inside of the current scope. If any test is focused, only focused tests will run. testFOCUS(&quot;1 == 1&quot;, function() assert(1 == 1) end)   "},{"title":"testSKIP​","type":1,"pageTitle":"x","url":"/midori/api/x#testSKIP","content":"&lt;/&gt; x.testSKIP( name: string, callback: (context: {}) → () ) → () Creates a new test inside of the current scope that will be skipped. testSKIP(&quot;skip&quot;, function() print(&quot;this will not print&quot;) end)   "},{"title":"beforeEach​","type":1,"pageTitle":"x","url":"/midori/api/x#beforeEach","content":"&lt;/&gt; x.beforeEach(callback: (context: {}) → ()) → () Runs callback before each test inside its scope runs. It's passed a context table unique to that test. context can be used to share setup code across tests. beforeEach(function(context) context.maid = Maid.new() end) test(function(context) assert(context.maid:isEmpty()) end)   "},{"title":"afterEach​","type":1,"pageTitle":"x","url":"/midori/api/x#afterEach","content":"&lt;/&gt; x.afterEach(callback: (context: {}) → ()) → () Runs callback after each test inside its scope runs. It's passed a context table which can be used to cleanup state unique to the test. afterEach(function(context) context.object:destroy() end)   "},{"title":"nested​","type":1,"pageTitle":"x","url":"/midori/api/x#nested","content":"&lt;/&gt; x.nested( name: string, callback: () → () ) → () Creates a nested scope for tests. It can be used to group tests that are testing similar things. nested(&quot;nested&quot;, function() -- This `beforeEach` will only affect tests inside of this nested scope. beforeEach(function() end) test(&quot;nested test&quot;, function() end) end)   "},{"title":"shouldThrow​","type":1,"pageTitle":"x","url":"/midori/api/x#shouldThrow","content":"&lt;/&gt; x.shouldThrow( callback: () → (), substring: string? ) → () Throws if the callback doesn't error or if the error does not contain substring. -- This will not throw because the callback errors with a string containing &quot;needle&quot; shouldThrow(function() error(&quot;haystick with a needle&quot;) end, &quot;needle&quot;)  "}]